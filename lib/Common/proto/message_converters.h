#ifndef MESSAGE_CONVERTERS_H
#define MESSAGE_CONVERTERS_H

#include "nanopb_cpp.h"
#include "system_state.h"
#include "sensors_state.h"
#include "measurements.h"
#include "notification_message.h"
#include "messages.pb.h"
#include "mcu_comms.h"

using namespace NanoPb::Converter;

/**
  * The below classes are converters that map our own classes to/from protobuf objects.
  * The protobuf objects are autogenerated at build time  based on the *.proto definition files
  * (see settings.proto and profile.proto).
  */

class OperationModeConverter : public NanoPb::Converter::EnumConverter<OperationModeConverter, OperationMode, OperationModeDto> {
public:
  static ProtoType encode(const LocalType& local) {
    switch (local) {
    case OperationMode::BREW_AUTO: return OperationModeDto::OperationModeDto_BREW_AUTO;
    case OperationMode::BREW_MANUAL: return OperationModeDto::OperationModeDto_BREW_MANUAL;
    case OperationMode::FLUSH: return OperationModeDto::OperationModeDto_FLUSH;
    case OperationMode::DESCALE: return OperationModeDto::OperationModeDto_DESCALE;
    case OperationMode::STEAM: return OperationModeDto::OperationModeDto_STEAM;
    case OperationMode::FLUSH_AUTO: return OperationModeDto::OperationModeDto_FLUSH_AUTO;
    }
    return OperationModeDto::OperationModeDto_BREW_AUTO;
  };

  static LocalType decode(const ProtoType& proto) {
    switch (proto) {
    case OperationModeDto::OperationModeDto_BREW_AUTO: return OperationMode::BREW_AUTO;
    case OperationModeDto::OperationModeDto_BREW_MANUAL: return OperationMode::BREW_MANUAL;
    case OperationModeDto::OperationModeDto_FLUSH: return OperationMode::FLUSH;
    case OperationModeDto::OperationModeDto_DESCALE: return OperationMode::DESCALE;
    case OperationModeDto::OperationModeDto_STEAM: return OperationMode::STEAM;
    case OperationModeDto::OperationModeDto_FLUSH_AUTO: return OperationMode::FLUSH_AUTO;
    }
    return OperationMode::BREW_AUTO;
  };
};

class SystemStateConverter : public NanoPb::Converter::MessageConverter<SystemStateConverter, SystemState, SystemStateDto, SystemStateDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return SystemStateDto{
      .startupInitFinished = local.startupInitFinished,
      .tofReady = local.tofReady,
      .isSteamForgottenON = local.isSteamForgottenON,
      .scalesPresent = local.scalesPresent,
      .operationMode = OperationModeConverter::encode(local.operationMode),
      .timeAlive = local.timeAlive,
      .tarePending = local.tarePending,
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return SystemStateDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.startupInitFinished = proto.startupInitFinished;
    local.tofReady = proto.tofReady;
    local.isSteamForgottenON = proto.isSteamForgottenON;
    local.scalesPresent = proto.scalesPresent;
    local.operationMode = OperationModeConverter::decode(proto.operationMode);
    local.timeAlive = proto.timeAlive;
    local.tarePending = proto.tarePending;
    return true;
  };
};

class UpdateSystemStateComandConverter : public NanoPb::Converter::MessageConverter<UpdateSystemStateComandConverter, UpdateSystemStateComand, UpdateSystemStateComandDto, UpdateSystemStateComandDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return UpdateSystemStateComandDto{
      .operationMode = OperationModeConverter::encode(local.operationMode),
      .tarePending = local.tarePending,
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return UpdateSystemStateComandDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.operationMode = OperationModeConverter::decode(proto.operationMode);
    local.tarePending = proto.tarePending;
    return true;
  };
};

class SensorStateSnapshotConverter : public NanoPb::Converter::MessageConverter<SensorStateSnapshotConverter, SensorStateSnapshot, SensorStateSnapshotDto, SensorStateSnapshotDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return SensorStateSnapshotDto{
      .brewActive = local.brewActive,
      .steamActive = local.steamActive,
      .hotWaterSwitchState = local.hotWaterSwitchState,
      .temperature = local.temperature,
      .waterTemperature = local.waterTemperature,
      .pressure = local.pressure,
      .pumpFlow = local.pumpFlow,
      .weightFlow = local.weightFlow,
      .weight = local.weight,
      .waterLevel = local.waterLevel,
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return SensorStateSnapshotDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.brewActive = proto.brewActive;
    local.steamActive = proto.steamActive;
    local.hotWaterSwitchState = proto.hotWaterSwitchState;
    local.temperature = proto.temperature;
    local.waterTemperature = proto.waterTemperature;
    local.pressure = proto.pressure;
    local.pumpFlow = proto.pumpFlow;
    local.weightFlow = proto.weightFlow;
    local.weight = proto.weight;
    local.waterLevel = proto.waterLevel;
    return true;
  };
};


class ShotSnapshotConverter : public NanoPb::Converter::MessageConverter<ShotSnapshotConverter, ShotSnapshot, ShotSnapshotDto, ShotSnapshotDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return ShotSnapshotDto{
      .timeInShot = local.timeInShot,
      .pressure = local.pressure,
      .pumpFlow = local.pumpFlow,
      .weightFlow = local.weightFlow,
      .temperature = local.temperature,
      .shotWeight = local.shotWeight,
      .waterPumped = local.waterPumped,
      .targetTemperature = local.targetTemperature,
      .targetPumpFlow = local.targetPumpFlow,
      .targetPressure = local.targetPressure ,
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return ShotSnapshotDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.timeInShot = proto.timeInShot;
    local.pressure = proto.pressure;
    local.pumpFlow = proto.pumpFlow;
    local.weightFlow = proto.weightFlow;
    local.temperature = proto.temperature;
    local.shotWeight = proto.shotWeight;
    local.waterPumped = proto.waterPumped;
    local.targetTemperature = proto.targetTemperature;
    local.targetPumpFlow = proto.targetPumpFlow;
    local.targetPressure = proto.targetPressure;
    return true;
  };
};

class MeasurementConverter : public NanoPb::Converter::MessageConverter<MeasurementConverter, Measurement, MeasurementDto, MeasurementDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return MeasurementDto{
      .value = local.value,
      .time = local.millis,
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return MeasurementDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.value = proto.value;
    local.millis = proto.time;
    return true;
  };
};

class NotificationTypeConverter : public NanoPb::Converter::EnumConverter<NotificationTypeConverter, NotificationType, NotificationDto_NotificationTypeDto> {
public:
  static ProtoType encode(const LocalType& local) {
    switch (local) {
    case NotificationType::INFO: return NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_INFO;
    case NotificationType::SUCCESS: return NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_SUCCESS;
    case NotificationType::WARN: return NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_WARN;
    case NotificationType::ERROR: return NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_ERROR;
    }
    return NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_INFO;
  };

  static LocalType decode(const ProtoType& proto) {
    switch (proto) {
    case NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_INFO: return  NotificationType::INFO;
    case NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_SUCCESS: return  NotificationType::SUCCESS;
    case NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_WARN: return  NotificationType::WARN;
    case NotificationDto_NotificationTypeDto::NotificationDto_NotificationTypeDto_ERROR: return  NotificationType::ERROR;
    }
    return NotificationType::INFO;
  };
};

class NotificationConverter : public NanoPb::Converter::MessageConverter<NotificationConverter, Notification, NotificationDto, NotificationDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return NotificationDto{
      .type = NotificationTypeConverter::encode(local.type),
      .message = NanoPb::Converter::StringConverter::encoderInit(local.message),
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return NotificationDto{
      .message = NanoPb::Converter::StringConverter::decoderInit(local.message),
    };
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.type = NotificationTypeConverter::decode(proto.type);
    return true;
  };
};

class McuCommsRequestDataConverter : public NanoPb::Converter::MessageConverter<McuCommsRequestDataConverter, McuCommsRequestData, RequestDataDto, RequestDataDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return RequestDataDto{
      .type = static_cast<uint8_t>(local.type),
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return RequestDataDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.type = static_cast<McuCommsMessageType>(proto.type);
    return true;
  };
};


class DescalingStateConverter : public NanoPb::Converter::EnumConverter<DescalingStateConverter, DescalingState, DescalingStateDto> {
public:
  static ProtoType encode(const LocalType& local) {
    switch (local) {
    case DescalingState::IDLE: return DescalingStateDto::DescalingStateDto_IDLE;
    case DescalingState::PHASE1: return DescalingStateDto::DescalingStateDto_PHASE1;
    case DescalingState::PHASE2: return DescalingStateDto::DescalingStateDto_PHASE2;
    case DescalingState::PHASE3: return DescalingStateDto::DescalingStateDto_PHASE3;
    case DescalingState::FINISHED: return DescalingStateDto::DescalingStateDto_FINISHED;
    }
    return DescalingStateDto::DescalingStateDto_IDLE;
  };

  static LocalType decode(const ProtoType& proto) {
    switch (proto) {
    case DescalingStateDto::DescalingStateDto_IDLE: return DescalingState::IDLE;
    case DescalingStateDto::DescalingStateDto_PHASE1: return DescalingState::PHASE1;
    case DescalingStateDto::DescalingStateDto_PHASE2: return DescalingState::PHASE2;
    case DescalingStateDto::DescalingStateDto_PHASE3: return DescalingState::PHASE3;
    case DescalingStateDto::DescalingStateDto_FINISHED: return DescalingState::FINISHED;
    }
    return DescalingState::IDLE;
  };
};


class DescalingProgressConverter : public NanoPb::Converter::MessageConverter<DescalingProgressConverter, DescalingProgress, DescalingProgressDto, DescalingProgressDto_fields> {
public:
  static ProtoType encoderInit(const LocalType& local) {
    return DescalingProgressDto{
      .state = DescalingStateConverter::encode(local.state),
      .time = local.time,
      .progess = local.progess,
    };
  };

  static ProtoType decoderInit(LocalType& local) {
    return DescalingProgressDto{};
  };

  static bool decoderApply(const ProtoType& proto, LocalType& local) {
    local.state = DescalingStateConverter::decode(proto.state);
    local.time = proto.time;
    local.progess = proto.progess;
    return true;
  };
};
#endif
